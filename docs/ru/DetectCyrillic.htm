<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<TITLE>Lingua::DetectCyrillic. Detection of 7 Cyrillic codings and 2 languages</TITLE>
<LINK REL="stylesheet" HREF="../pod.css" TYPE="text/css">
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>

<script language=javascript1.2>var MenuBuiltOnServer=0;</script>
<!--#include virtual="../menu.pl" -->
<script language=javascript1.2 src="../Languages.inc"></script>
<script language=javascript1.2 src="./Menu.inc"></script>
<script language=javascript1.2 src="../MakeMenu.js"></script>

<hr>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;Lingua::DetectCyrillic.
Определение 7 кириллических кодировок и 2
языков</P></STRONG></FONT>
</TD></TR>
</TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<UL>

		<LI><A HREF="#annotation">АННОТАЦИЯ</A></LI>
		<LI><A HREF="#synopsis">СИНОПСИС</A></LI>
		<LI><A HREF="#description">ОПИСАНИЕ</A></LI>
		<LI><A HREF="#dependencies">НЕОБХОДИМЫЕ ПАКЕТЫ</A></LI>
		<LI><A HREF="#usage details">ПОДРОБНОСТИ
          ИСПОЛЬЗОВАНИЯ</A></LI>
		<LI><A HREF="#how it works">КАК ЭТО РАБОТАЕТ</A></LI>
		<UL>

			<LI><A HREF="#stage 1. formal analysis of alphabet hits and capitalization">Этап 1.
              Формальный анализ соответствия
              алфавиту и капитализации слов</A></LI>
			<LI><A HREF="#stage 2. frequency analysis of words and 2letter combinations.">Этап
              2. Частотный анализ слов и 2-буквенных
              сочетаний</A></LI>
		</UL>

		<LI><A HREF="#reference information">СПРАВОЧНАЯ ИНФОРМАЦИЯ</A></LI>
		<UL>

			<LI><A HREF="#modern cyrillic codings and where are they used">Современные
              кириллические кодировки и где они
              используются</A></LI>
			<LI><A HREF="#algorithm codes explanation">Объяснение
              кодов алгоритма</A></LI>
		</UL>

		<LI><A HREF="#history">ИСТОРИЯ</A></LI>
		<LI><A HREF="#todo">ПЛАНЫ</A></LI>
		<LI><A HREF="#contacts and copyright">КОНТАКТЫ И
          АВТОРСКОЕ ПРАВО</A></LI>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H2><A NAME="annotation">АННОТАЦИЯ</A></H2>
<P><STRONG>Lingua::DetectCyrillic</STRONG>. Пакет определяет 7
кодировок кириллицы, а также язык - русский
или английский. Использует встроенные
частотные словари; обычно для правильного
определения достаточно одного слова.</P>
<P>
<H2><A NAME="synopsis">СИНОПСИС</A></H2>
<PRE>
  use Lingua::DetectCyrillic;
   -or (if you need translation functions) -
  use Lingua::DetectCyrillic qw ( &amp;TranslateCyr &amp;toLowerCyr &amp;toUpperCyr );</PRE>
<PRE>
  # Новый класс Lingua::DetectCyrillic. По умолчанию анализируется не более 100 
  # кириллических токенов (слов); украинский язык не определяется.
  $CyrDetector = Lingua::DetectCyrillic -&gt;new();</PRE>
<PRE>
  # То же самое, но: анализировать по меньшей мере 200 токенов, определять русский 
  # и украинский.
  $CyrDetector = Lingua::DetectCyrillic -&gt;new( MaxTokens =&gt; 200, DetectAllLang =&gt; 1 );</PRE>
<PRE>
  # Определить кодировку и язык
  my ($Coding,$Language,$CharsProcessed,$Algorithm)= $CyrDetector -&gt; Detect( @Data );</PRE>
<PRE>
  # Вывести отчет
  $CyrDetector -&gt; LogWrite(); #на STDOUT
  $CyrDetector -&gt; LogWrite('report.log'); #в файл</PRE>
<PRE>
  # Перевод в нижний регистр (предполагается, что исходная кодировка - windows-1251)
  $s=toLowerCyr($String, 'win');
  # Перевод в верхний регистр (предполагается, что исходная кодировка - windows-1251)
  $s=toUpperCyr($String, 'win');
  # Перевод из одной кодировки в другую
  # Возможные варианты: win, koi, koi8u, mac, iso, dos, utf
  $s=TranslateCyr('win', 'koi',$String);</PRE>
<P>См. <A HREF="#usage details">Дополнительную
информацию по использованию пакета </A>.</P>
<P>
<H2><A NAME="description">ОПИСАНИЕ</A></H2>
<P>Данный пакет позволяет определить
автоматически все &quot;живые&quot; кодировки
кириллицы -
<A HREF="#item_windows%2d1251">windows-1251</A>, <A HREF="#item_koi8%2dr">koi8-r</A>,
<A HREF="#item_koi8%2du">koi8-u</A>, <A HREF="#item_iso%2d8859%2d5">iso-8859-5</A>,
<A HREF="#item_utf%2d8">utf-8</A>, <A HREF="#item_cp866">cp866</A>,
<A HREF="#item_x%2dmac%2dcyrillic">x-mac-cyrillic</A>, а также язык
-&nbsp; <STRONG>Русский</STRONG> или <STRONG>Украинский</STRONG>.
Он применяет 3 алгоритма для определения: <A HREF="#stage 1. formal analysis of alphabet hits and capitalization">формальный
анализ попадания в алфавит</A>, <A HREF="#stage 2. frequency analysis of words and 2letter combinations.">частотный
анализ слов и частотный анализ 2-буквенных
сочетаний</A>.</P>
<P>Пакет также имеет процедуры для
конвертирования различныъ кодировок
кириллических текстов, которые можно при
необходимости импортировать.</P>
<P>Пакет позволяет определить кодировку с
одного-двух слов. Естественно, в случае
одного слова надежность будет низкой,
особенно если все слово написано строчными
или прописными буквами, так как анализ
капитализации слов является важным
моментом при определении кодировки. Тем не
менее пакет корректно распознает кодировку
сообщений, состоящих из одного слова, даже
строчными буквами - &quot;привет&quot;, &quot;иван&quot;,
&quot;водка&quot;, &quot;спутник&quot;. ;-)))</P>
<P>Украинский язык будет определен, только
если в тексте имеются специфичные
украинские буквы.</P>
<P>Производительность довольно неплохая, т.к.
анализ проходит две фазы: на первой
производится только быстрый формальный
анализ правильности капитализации и выхода
за пределы алфавита, и только если этого
недостаточно,&nbsp; данные анализируются
повторно - по частотным словарям.</P>
<P>
<H2><A NAME="dependencies">НЕОБХОДИМЫЕ ПАКЕТЫ</A></H2>
<P>Пока пакет требует <STRONG><A HREF="#item_unicode%3a%3astring">Unicode::String</A></STRONG> 
и
<STRONG><A HREF="#item_unicode%3a%3amap8">Unicode::Map8</A>,</STRONG>
 которые можно загрузить с <A HREF="http://www.cpan.org.">http://www.cpan.org.</A>
 См. <A HREF="#which additional packages are required">Дополнительную
информацию по пакетам, которые нужно
установить</A>.</P>
<P>Я планирую реализовать собственную
поддержку декодирования символов, так что в
следующих выпусках необходимости в этих
пакетах не будет.</P>
<OL>
<LI><STRONG><A NAME="item_Unicode%3A%3AMap8"><STRONG>Unicode::Map8</STRONG></A></STRONG><BR>

  Базовый пакет для конвертации между
  различными однобайтовыми кодировками.
  Доступен на <A HREF="http://www.cpan.org">http://www.cpan.org</A> .<P><STRONG>Внимание!</STRONG> 
  Этот модуль требует предварительной
  компиляции на&nbsp; C++; под Юниксом эта
  операция проходит гладко и не требует
  комментариев; но под Win32 и ActiveState Perl вы
  должны</P>
<OL>
<LI><STRONG><A NAME="item_use_MS_Visual_C%2B%2B_and">использовать MS Visual C++
  и</A></STRONG><BR>

<LI><STRONG><A NAME="item_make_some_manual_changes_to_the_listing_after_havi">произвести
  в листинге после отработки Makefile.PL
  следующие замены вручную</A>&nbsp;</STRONG><BR>

  Откройте <STRONG>map8x.c</STRONG>  и замените строку 97
  с
<PRE>
    ch = PerlIO_getc(f);</PRE>
<P>на</P>
<PRE>
    ch = getc(f);</PRE>
  <P>Одним словом, нужно заменить&nbsp; оболочку
  Perl для функции Си <EM>getc</EM>  на саму эту
  функцию. Компилятор выдает
  предупреждениям, но в итоге вы получаете 100%
  работающую DLL.</P>
<P></P></OL>
<LI><STRONG><A NAME="item_Unicode%3A%3AString"><STRONG>Unicode::String</STRONG></A></STRONG><BR>

  Обеспечивает поддержку для <STRONG>Unicode::Map8</STRONG>.
  Имеется на&nbsp; <A HREF="http://www.cpan.org">http://www.cpan.org</A> .
<P></P></OL>
<P>
<H2><A NAME="usage details">ПОДРОБНОСТИ ИСПОЛЬЗОВАНИЯ</A></H2>
<UL>
<LI><strong><A NAME="item_Create_a_class_Lingua%3A%3ADetectCyrillic">Создать
  класс Lingua::DetectCyrillic</A></strong><BR>

<PRE>
  $CyrDetector = Lingua::DetectCyrillic -&gt;new();
  $CyrDetector = Lingua::DetectCyrillic -&gt;new( MaxTokens =&gt; 100, DetectAllLang =&gt; 1 );</PRE>
  <P><EM>MaxTokens</EM> - пакет <EM>прекращает анализ</EM>
  данных, если достигнуто требуемое число
  кириллических токенов. Не нужно
  анализировать все 100 или 200 тысяч байт, если
  после первых 100 токенов кодировка и язык
  очевидны. По умолчанию этот аргумент равен
  100.</P>
  <P><EM>DetectAllLang</EM> - по умолчанию пакет
  предполагает, что работает только с
  русским языком. Установка этого параметра
  в любое ненулевое значение приведет к
  анализу двух языков - русского и
  украинского. Это несколько уменьшает
  производительность (около 10%) и в редких
  случаях может привести к худшему
  определению кодировки.</P>
<LI><STRONG><A NAME="item_Pass_an_array_of_strings_to_the_class_method_Detec">Передать
  массив строк методу класса <EM>Detect</EM>:</A></STRONG><BR>

<PRE>
 my ($Coding,$Language,$CharsProcessed,$Algorithm)= $CyrDetector -&gt; Detect( @Data );</PRE>
<DL>
<DT><STRONG><A NAME="item_%24Coding">$Coding</A></STRONG><BR>
<DD>
- <A HREF="#item_windows%2d1251">windows-1251</A>, <A HREF="#item_koi8%2dr">koi8-r</A>,
<A HREF="#item_iso%2d8859%2d5">iso-8859-5</A>, <A HREF="#item_utf%2d8">utf-8</A>, <A HREF="#item_cp866">cp866</A>,
<A HREF="#item_x%2dmac%2dcyrillic">x-mac-cyrillic</A>. Если в данных
не встретилось ни одного кириллического
символа, возвращает <STRONG>iso-8859-1</STRONG>. Если
<EM>DetectAllLang &gt; 0</EM>, может вернуть также <A HREF="#item_koi8%2du">koi8-u</A>.
<P></P>
<DT><STRONG><A NAME="item_%24Language">$Language</A></STRONG><BR>
<DD>
- <STRONG>Rus</STRONG>  или (если <EM>DetectAllLang &gt; 0</EM>)
также и <STRONG>Ukr</STRONG>. Если не встретилось ни
одного кириллического символа, возвращает <STRONG>NoLang</STRONG> 
(я не могу утверждать наверняка, что этот
язык - английский, немецкий, французский или
любой иной ;-).
<P></P>
<DT><STRONG><A NAME="item_%24CharsProcessed">$CharsProcessed</A></STRONG><BR>
<DD>
- число обработанных символов в наиболее
вероятной кодировке. Полезно для
определения уровня надежности. Если
программа нашла в данных всего 3-4
несчастных символа, нечего говорить,
насколько точны результаты...
<p>&nbsp;</p>
<P></P>
<DT><STRONG><A NAME="item_%24Algorithm">$Algorithm</A></STRONG><BR>
<DD>
- числовой код, показывающий, на каком этапе
программа приняла решение остановить
дальнейший анализ (удовлетворилась
результатами). Если будете писать мне об
ошибках, пожалуйста, указывайте и этот код.
Более подробная информация - в таблице <A HREF="#algorithm codes explanation">Объяснение
кодов алгоритма</A>.
<P></P></DL>
<LI><STRONG><A NAME="item_Write_a_report%2C_if_you_want">Вывести
  отчет, если желаете</A></STRONG><BR>

<PRE>
  $CyrDetector -&gt; LogWrite(); #write to STDOUT
  $CyrDetector -&gt; LogWrite('report.log'); #write to file</PRE>
  <P>Если единственный аргумент не указан или
  равен <EM>stdout</EM>  (в любом регистре),
  программа выводит отчет на <STRONG>STDOUT</STRONG>,
  иначе в файл.</P>
</UL>
<P>
<H2><A NAME="how it works">КАК ЭТО РАБОТАЕТ</A></H2>
<P>
<H3><A NAME="stage 1. formal analysis of alphabet hits and capitalization">Этап
1. Формальный анализ соответствия алфавиту
и капитализации слов</A></H3>
<P>Начиная программировать, я исходил из
очевидного факта: человек легко определяет
кодировку и язык с одного взгляда, или по
меньшей мере может сказать, что <i>текст
отображается в неправильной кодировке</i>.
Дело в том, что <i>алфавиты</i>, т.е. <i>буквы</i>
большинства кириллических кодировок, <i>не </i>совпадают,
так что если мы попытаемся вывести текст на
экран в неверной кодировке, то <i>неизбежно </i>увидим
непонятные символы внутри слов, которые
нельзя напечатать с русской или украинской
клавиатуры обычным путем - знаки валюты,
пунктуацию, буквы сербского языка, иногда -
бинарные символы и т.п.</P>
<P>В сущности, мы имеем только один непростой
случай: алфавит двух наиболее популярных
кириллических кодировок -
windows-1251 и koi8-r - расположен в одном диапазоне,
но <i>прописные </i>буквы windows-1251 расположены
на месте <i>строчных </i>букв&nbsp; koi8-r и
наоборот, так что &quot;Иван Петров&quot; в одной
из этих кодировок будет выглядеть как &quot;иВАН
пЕТРОВ&quot; в другой, т.е. иметь совершенно
неверную <i>капитализацию слов</i>, что также
может быть легко установлено формальным
анализом букв. А как легко догадаться, любой
более-менее реальный кириллический текст
должен иметь по меньшей мере одно слово,
начинающееся с прописной буквы (я не
рассматриваю здесь некоторых странных
обитателей Интернета, которые ПИШУТ ВСЕ
ПРОПИСНЫМИ БУКВАМИ ;-).</P>
Итак, на первой стадии анализа программа
последовательно предполагает, что данный
текст написан в одной из 6 или 7
кириллических кодировок и подсчитывает:
<div style='position:relative;left:30'>
1. сколько токенов имеет внутри &quot;неверные&quot;
символы, которые не являются частью
русского или украинского алфавитов и не
могут быть напечатаны со стандартной
клавиатуры; <br>
2. у скольких токенов&nbsp; неправильная
капитализация, которая отличается от
стандартных слов в <i>ПРОПИСНОЙ, строчной </i>и
<i>Заглавной </i>капитализации.
</div><P>Этот формальный анализ проходит
быстро и он достаточен в 99.9% <i>реальных </i>текстов.&nbsp;
Неправильные кодировки легко
отфильтровываются и мы получаем одного &quot;абсолютного
победителя&quot;. Этот метод также достаточно
надежен: я с трудом могу представить
нормального человека, пишущего в обратной
капитализации. Но что если у нас только
несколько слов и все они в верхнем или
нижнем регистре?</P>
<P>&nbsp;</P>
<P>
<H3><A NAME="stage 2. frequency analysis of words and 2letter combinations.">Этап
2. Частотный анализ слов и 2-буквенных
сочетаний</A></H3>
<P>В данном случае мы применяем частотный
анализ слов и 2-буквенных сочетаний,
называемые также <i>хэшами </i>(естественно,
не в том смысле, в каком это слово
употребляется в Перле).</P>
<P>В пакет входят словари на 300 наиболее
частотных русских и украинских слов и
примерно 600 русских и украинских
двухбуквенных сочетаний, построенные мной
самим (исходные тексты, возможно, были не
очень характерными для авторов Интернета,
но любой лингвист заверит, что это не очень
принципиально: первые несколько сотен
наиболее популярных слов в любом языке
очень стабильны, не говоря уже о
частотности буквенных сочетаний).&nbsp;</P>
<P>Итак, текст анализируется во второй раз (это
не должно занять слишком много времени, так
как мы можем попасть в данную ситуацию
только в случае очень короткого текста);
анализируются уже все кириллические буквы,
невзирая на капитализацию. Если мы нашли
хоть одно слово по словарю - кодировка
определена, иначе анализируются хэши.</P>
<P>В некоторых редких случаях (обычно в
крайне искусственной ситуации, когда у нас
всего одно короткое слово, и оно написано в
верхнем или нижнем регистре), статистика по
нескольким кодировкам совпадает. Тогда мы
предпочитаем&nbsp; windows-1251 кодировке mac, koi8-r -
кодировке koi8-u и - если ничего не помогает -
предпочитаем windows-1251 кодировке koi8-r.</P>
<P>Чтобы знать, какой алгоритм применялся, мы
можем проанализировать 4-ю переменную,
возвращаемую функцией <EM>Detect</EM> - <A HREF="#item_%24algorithm">$Algorithm</A>.
Более детальная информация - в таблице <A HREF="#algorithm codes explanation">Объяснение
кодов алгоритма</A></P>
<P>
<H2><A NAME="reference information">СПРАВОЧНАЯ ИНФОРМАЦИЯ</A></H2>
<P>
<H3><A NAME="modern cyrillic codings and where are they used">Современные
кириллические кодировки и где они
используются</A></H3>
<P>Имеются следующие кодировки:</P>
<UL>
<LI><STRONG><A NAME="item_windows%2D1251">windows-1251</A></STRONG><BR>

  Наиболее популярная кириллическая
  кодировка сегодня, используемая примерно
  на 99% PC. Полный алфавит начинается с кода 192
  (прописная <b>А</b>), как большинство
  кодировок Microsoft для национальных языков, и
  заканчивается кодом 255 (строчная <b>я</b>).
  Содержит также символы для украинского,
  белорусского и других языков на основе
  кириллицы. Может легко сортироваться и т.п.
<P></P>
<LI><STRONG><A NAME="item_koi8%2Dr">koi8-r</A></STRONG><BR>

  Транслитерированная кодировка, кошмарное
  наследие старого 7-битового мира :-).
  Поначалу была изобретена другая кодировка
  - koi7-r, где русские буквы находились на
  местах <b>похожих</b> английских, например,
  русское А на месте английского А, русское Р
  на месте английского R и т.п. Даже если в
  системе отсутствовали кириллические
  шрифты, текст оставался читабельным. <EM>Koi8-r</EM> 
  в сущности все та же археологическая&nbsp; <EM>Koi7-r</EM> 
  с буквами, сдвинутыми в верхнюю часть
  таблицы ASCII. <EM>Koi8-r</EM>  все еще применяется
  на компьютерах под Юникс, поэтому это
  вторая по популярности кодировка в
  Интернете.
<P></P>
<LI><STRONG><A NAME="item_koi8%2Du">koi8-u</A></STRONG><BR>

  То же, что и koi8-r, но с добавленными
  украинскими буквами.
<P></P>
<LI><STRONG><A NAME="item_utf%2D8">utf-8</A></STRONG><BR>

  Хорошее текстовое представление текста в Unicode.
  Символы с кодами до 128 представлены
  однобайтовыми кодами, другие (за
  исключением восточных языков) -
  двухбайтовыми последовательностями.
  Более подробная информация в RFC 2279 &quot;UTF-8, a transformation
format of ISO 10646&quot;.
<P></P>
<LI><STRONG><A NAME="item_iso%2D8859%2D5">iso-8859-5</A></STRONG><BR>

  Хотя эта кодировка одобрена ISO, она
  используется только на некоторых редких Unix-системах,
  в частности, на русском Солярисе. За всю
  свою жизнь в Интернете я встретил только
  пару людей, работающих на таких
  компьютерах.
<P></P>
<LI><STRONG><A NAME="item_cp866">cp866</A></STRONG><BR>

  Также называется &quot;альтернативной&quot;
  кодировкой. Использовалась под&nbsp; DOS и
  русской OS/2.
<P></P>
<LI><STRONG><A NAME="item_x%2Dmac%2Dcyrillic">x-mac-cyrillic</A></STRONG><BR>

  Кодировка Макинтош. Строчные буквы почти
  полностью совпадают с Windows-1251 (кроме 2
  символов), так что в редких случаях <EM>x-mac-cyrillic</EM> 
  можно спутать с <EM>windows-1251</EM>. В Интернете
  эта кодировка практически вымерла; ее доля
  абсолютно незначительна. На платформе PC
  она поддерживается по умолчанию только
  под Windows NT+.
<P></P></UL>
<P>
<H3><A NAME="algorithm codes explanation">Объяснение кодов
алгоритма</A></H3>
<table width="80%">
     <th colspan=2> Объяснение кодов алгоритма </th>
     <tr class=tr1><td width=5%>11</td><td width=40%>Формальный
        анализ количества/капитализации
        кириллических символов; найдена только
        одна альтернатива</td></tr>
     <tr><td>21</td><td>Формальный анализ количества/капитализации
        кириллических символов; найдены две
        альтернативы (koi8-r и koi8-u); выбрана koi8-r</td></tr>
     <tr class=tr1><td>22</td><td>Формальный анализ
        количества/капитализации
        кириллических символов; найдены две
        альтернативы (win1251 и mac); выбрана win1251</td></tr>
     <tr><td>31</td><td>Найдено по меньшей мере одно
        слово из словаря и есть только одна
        альтернатива</td></tr>
     <tr class=tr1><td>32</td><td>Найдено по меньшей мере
        одно слово из хэша и есть только одна
        альтернатива</td></tr>
     <tr><td>33</td><td>Формально определена win1251 (скорее
        всего, на базе анализа хэша)</td></tr>
     <tr class=tr1><td>34</td><td>Формально определена koi8-r
        (скорее всего на базе анализа хэша)</td></tr>
     <tr><td>40</td><td>Был выбран наиболее вероятный
        результат, но надежность очень
        невелика</td></tr>
     <tr class=tr1><td>100</td><td>Не найдено ни одного
        кириллического символа</td></tr>
</table><P>
<H2><A NAME="history">ИСТОРИЯ</A></H2>
<P>01 декабря 2002 - Добавлена полная документация на русском языке. Версия заменена на 0.02.</P>
<P>19 ноября 2002 - выпущена версия 0.01.</P>
<P>
<H2><A NAME="todo">ПЛАНЫ</A></H2>
<P>1. Собственная поддержка Unicode.</P>
<P>2. Возможность определять только
необходимые кодировки из списка.</P>
<P>Что еще? Нужны ваши предложения!!</P>
<P>
<H2><A NAME="contacts and copyright">КОНТАКТЫ И АВТОРСКОЕ
ПРАВО</A></H2>
<P>Автор: <STRONG>Алексей Руденко</STRONG>, Россия,
Москва.&nbsp; Мой домашний телефон <EM>(095) 468-95-63</EM></P>
<P>Web-site: <A HREF="http://www.bible.ru/DetectCyrillic/">http://www.bible.ru/DetectCyrillic/</A></P>
<P>Адрес на CPAN: <A HREF="http://search.cpan.org/author/RUDENKO/">http://search.cpan.org/author/RUDENKO/</A></P>
<P>Email: <A HREF="mailto:rudenko@bible.ru">rudenko@bible.ru</A></P>
<P>Copyright (c) 2002 Alexei Rudenko. All rights reserved.</P>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<p CLASS="block">
<FONT SIZE=+1><STRONG>&nbsp;Lingua::DetectCyrillic. Определение 7
кириллических кодировок и 2 языков</STRONG></FONT>
</TD></TR>
</TABLE>

</BODY>

</HTML>
